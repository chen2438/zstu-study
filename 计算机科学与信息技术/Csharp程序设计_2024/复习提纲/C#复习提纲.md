# 复习提纲



# 考点分析

## 2023卷

### 一、判断题



1. **值类型和引用类型**：
   - 题目：int类型是值类型还是引用类型？
   - 考点：值类型和引用类型
2. **Equals方法**：
   - 题目：两个类实例使用Equals方法比较是否相等。
   - 考点：Equals方法
3. **委托定义**：
   - 题目：委托的返回值类型是否可以是void。
   - 考点：委托定义
4. **IList接口**：
   - 题目：IList接口是否允许通过索引访问集合中的元素。
   - 考点：IList接口
5. **WPF事件类型**：
   - 题目：WPF中的事件类型是否为路由事件。
   - 考点：WPF事件类型



### 二、单选题



1. **IL指令集**：
   - 题目：IL指令集是否独立于CPU。
   - 考点：IL指令集
2. **构造方法特征**：
   - 题目：构造方法的特征。
   - 考点：构造方法特征
3. **函数重载**：
   - 题目：函数重载的条件。
   - 考点：函数重载
4. **方法参数修饰关键字**：
   - 题目：方法参数修饰关键字的作用。
   - 考点：方法参数修饰关键字
5. **委托**：
   - 题目：委托的特性。
   - 考点：委托
6. **常量定义**：
   - 题目：常量的定义方法。
   - 考点：常量定义
7. **属性**：
   - 题目：属性的定义和使用。
   - 考点：属性
8. **继承关系**：
   - 题目：继承关系的特性。
   - 考点：继承关系
9. **面向对象应用**：
   - 题目：面向对象编程的应用。
   - 考点：面向对象应用
10. **接口实现**：
    - 题目：接口的实现方法。
    - 考点：接口实现
11. **派生类**：
    - 题目：派生类的特性。
    - 考点：派生类
12. **抽象方法**：
    - 题目：抽象方法的定义和使用。
    - 考点：抽象方法
13. **Action委托**：
    - 题目：Action委托的特性。
    - 考点：Action委托
14. **Lambda表达式**：
    - 题目：Lambda表达式的使用。
    - 考点：Lambda表达式
15. **String创建**：
    - 题目：String对象的创建方法。
    - 考点：String创建
16. **List排序**：
    - 题目：List排序的方法。
    - 考点：List排序
17. **WPF布局**：
    - 题目：WPF布局面板的类型。
    - 考点：WPF布局
18. **LINQ查询**：
    - 题目：LINQ查询的扩展方法。
    - 考点：LINQ查询
19. **var类型**：
    - 题目：var类型的使用。
    - 考点：var类型
20. **FileStream对象**：
    - 题目：FileStream对象的使用。
    - 考点：FileStream对象



### 三、程序设计题



1. **整数列表操作**：
   - 题目：实现FilterList、MapList和IsPrime方法。
   - 考点：整数列表操作、Lambda表达式、委托
2. **单向链表实现**：
   - 题目：实现MyLinkedList类，包含IMyList接口的实现。
   - 考点：单向链表实现、接口实现、面向对象编程
3. **文件操作和数据统计**：
   - 题目：读取文件数据并统计名字中最流行的字，使用LINQ查询。
   - 考点：文件操作、数据统计、LINQ查询



通过以上分析，可以看出每一题具体涉及的考点，帮助你更有针对性地进行复习。





## 2022卷

### 一、选择题



1. **方法参数修饰关键字**：
   - 题目：int a = 100; void Func(ref int b) { } 则以下函数调用正确的是？
   - 考点：方法参数修饰关键字
2. **数据类型**：
   - 题目：以下数据类型中不可以使用算术运算的是？
   - 考点：数据类型
3. **数组初始化**：
   - 题目：下列数组初始化语句哪个是错误的？
   - 考点：数组初始化
4. **foreach语句**：
   - 题目：有关foreach(type identifier in name) { statement; } 语句描述不正确的是？
   - 考点：foreach语句
5. **委托**：
   - 题目：关于委托的说法，不正确的是？
   - 考点：委托
6. **继承关系**：
   - 题目：如果Employee从Person继承，Manager从Employee继承，下面哪条语句是有效的？
   - 考点：继承关系
7. **接口实现**：
   - 题目：假设HouseBoat类隐式实现了IHouse接口，显式实现了IBoat接口，下面哪条语句是错误的？
   - 考点：接口实现
8. **Action委托**：
   - 题目：声明Action<Order>变量时，该变量代表下面的哪一项？
   - 考点：Action委托
9. **字符串操作**：
   - 题目：对于字符串实例string str = “Hello”，以下哪个操作是可行的？
   - 考点：字符串操作
10. **WPF布局控件**：
    - 题目：在WPF控件中，最常用的布局控件是？
    - 考点：WPF布局控件
11. **方法重载**：
    - 题目：下列关于“方法重载”的描述中，哪个选项是不正确的？
    - 考点：方法重载
12. **WPF控件**：
    - 题目：WPF窗体中有一个年龄文本框 txtAge，下面代码可以获得文本框中的年龄值。
    - 考点：WPF控件
13. **泛型**：
    - 题目：以下关于泛型的叙述中错误的是？
    - 考点：泛型
14. **枚举类型**：
    - 题目：当你需要使用一种数据类型表达同一类事物的不同状态时，C#中最可靠和直观的解决方案是什么？
    - 考点：枚举类型
15. **方法重载**：
    - 题目：在C#程序中，定义如下方法，下面选项中错误的实现对该方法的方法重载。
    - 考点：方法重载
16. **结构和类**：
    - 题目：以下关于结构的说法，正确的是？
    - 考点：结构和类
17. **base关键字**：
    - 题目：关于base关键字，下列使用方法错误的是？
    - 考点：base关键字
18. **XAML文件**：
    - 题目：对于WPF中XAML文件的功能，说法不正确的是？
    - 考点：XAML文件
19. **LINQ查询**：
    - 题目：关于LINQ的说法正确的是？
    - 考点：LINQ查询
20. **集合类型**：
    - 题目：关于集合类型，不正确的是？
    - 考点：集合类型



### 二、判断题



1. **对象构建顺序**：
   - 题目：C#中对象构建时，先执行字段赋值再执行构造方法。
   - 考点：对象构建顺序
2. **方法与属性**：
   - 题目：方法能做到的事，属性也能做到。
   - 考点：方法与属性
3. **[ADO.NET](https://ado.net/) Entity Framework**：
   - 题目：[ADO.NET](https://ado.net/) Entity Framework提供了对象与数据库表的映射。
   - 考点：[ADO.NET](https://ado.net/) Entity Framework
4. **构造方法**：
   - 题目：构造方法应返回true或false以表明对象是否成功构造。
   - 考点：构造方法
5. **WPF控件模板**：
   - 题目：WPF中的控件由模板构建，因此其外观可利用模板技术重新定义。
   - 考点：WPF控件模板



### 三、程序设计题



1. **字符串操作**：
   - 题目：写一个方法string RemoveDuplicates(string str)，它能够将字符串中的重复字符删去。
   - 考点：字符串操作
2. **三维点和三角形类**：
   - 题目：定义并实现三角形类，包含三维点的定义和操作。
   - 考点：三维点和三角形类
3. **文件操作和数据统计**：
   - 题目：写一个程序，读取《三国演义》文本，并进行统计。
   - 考点：文件操作、数据统计、Lambda表达式、LINQ查询



通过以上分析，可以看出每一题具体涉及的考点，帮助你更有针对性地进行复习。





# 复习建议

## 2022

根据前面两份试卷的考点，结合目录中的章节和页数，以下是涉及考点的章节小节和页数：



### 一、选择题



1. **方法参数修饰关键字**
   - 章节：第6章 函数
   - 页数：82
2. **数据类型**
   - 章节：第3章 变量和表达式
   - 页数：26
3. **数组初始化**
   - 章节：第5章 变量的更多内容
   - 页数：66
4. **foreach语句**
   - 章节：第4章 流程控制
   - 页数：48
5. **委托**
   - 章节：第6章 函数
   - 页数：88
6. **继承关系**
   - 章节：第9章 面向对象编程
   - 页数：137
7. **接口实现**
   - 章节：第9章 面向对象编程
   - 页数：141
8. **Action委托**
   - 章节：第6章 函数
   - 页数：88
9. **字符串操作**
   - 章节：第5章 变量的更多内容
   - 页数：73
10. **WPF布局控件**
    - 章节：第14章 基本桌面编程
    - 页数：328
11. **方法重载**
    - 章节：第6章 函数
    - 页数：82
12. **WPF控件**
    - 章节：第14章 基本桌面编程
    - 页数：328
13. **泛型**
    - 章节：第9章 面向对象编程
    - 页数：142
14. **枚举类型**
    - 章节：第5章 变量的更多内容
    - 页数：61
15. **方法重载**
    - 章节：第6章 函数
    - 页数：82
16. **结构和类**
    - 章节：第5章 变量的更多内容
    - 页数：64
17. **base关键字**
    - 章节：第9章 面向对象编程
    - 页数：141
18. **XAML文件**
    - 章节：第14章 基本桌面编程
    - 页数：328
19. **LINQ查询**
    - 章节：第22章 LINQ
    - 页数：478
20. **集合类型**
    - 章节：第5章 变量的更多内容
    - 页数：66



### 二、判断题



1. **对象构建顺序**
   - 章节：第9章 面向对象编程
   - 页数：137
2. **方法与属性**
   - 章节：第6章 函数
   - 页数：82
3. **[ADO.NET](https://ado.net/) Entity Framework**
   - 章节：第23章 数据访问
   - 页数：500
4. **构造方法**
   - 章节：第9章 面向对象编程
   - 页数：137
5. **WPF控件模板**
   - 章节：第14章 基本桌面编程
   - 页数：328



### 三、程序设计题



1. **字符串操作**
   - 章节：第5章 变量的更多内容
   - 页数：73
2. **三维点和三角形类**
   - 章节：第9章 面向对象编程
   - 页数：137
3. **文件操作和数据统计**
   - 章节：第20章 文件操作
   - 页数：441



通过以上章节和页数的定位，可以更有针对性地进行复习，确保对每个考点的理解和掌握。

### 复习页数位置（按升序排列）



1. **第3章 变量和表达式**
   - 页数：26
   - 复习建议：重点复习数据类型的定义和使用，特别是哪些数据类型不可以使用算术运算。
2. **第4章 流程控制**
   - 页数：48
   - 复习建议：复习foreach语句的使用方法和注意事项，确保理解其正确用法。
3. **第5章 变量的更多内容**
   - 页数：61
   - 复习建议：复习枚举类型的定义和使用，理解其在表达同一类事物的不同状态时的应用。
4. **第5章 变量的更多内容**
   - 页数：64
   - 复习建议：复习结构和类的区别和使用场景，理解结构的特性。
5. **第5章 变量的更多内容**
   - 页数：66
   - 复习建议：复习数组初始化的方法和集合类型的使用，确保理解正确的初始化方式和集合类型的特性。
6. **第5章 变量的更多内容**
   - 页数：73
   - 复习建议：复习字符串操作的方法，特别是如何删除字符串中的重复字符。
7. **第6章 函数**
   - 页数：82
   - 复习建议：复习方法参数修饰关键字、方法重载的条件和特性，确保理解函数的定义和调用。
8. **第6章 函数**
   - 页数：88
   - 复习建议：复习委托和Action委托的定义和使用，理解其在函数中的应用。
9. **第9章 面向对象编程**
   - 页数：137
   - 复习建议：复习继承关系、对象构建顺序、构造方法的定义和使用，确保理解面向对象编程的核心概念。
10. **第9章 面向对象编程**
    - 页数：141
    - 复习建议：复习接口实现和base关键字的使用，理解接口和基类在面向对象编程中的作用。
11. **第9章 面向对象编程**
    - 页数：142
    - 复习建议：复习泛型的定义和使用，理解泛型在提高代码复用性和类型安全性方面的作用。
12. **第14章 基本桌面编程**
    - 页数：328
    - 复习建议：复习WPF布局控件、WPF控件模板和XAML文件的功能，确保理解WPF的基本概念和应用。
13. **第20章 文件操作**
    - 页数：441
    - 复习建议：复习文件操作的方法，特别是如何读取文件数据并进行统计，理解文件操作在实际编程中的应用。
14. **第22章 LINQ**
    - 页数：478
    - 复习建议：复习LINQ查询的基本方法和扩展方法，确保理解LINQ在数据查询和处理中的应用。
15. **第23章 数据访问**
    - 页数：500
    - 复习建议：复习[ADO.NET](https://ado.net/) Entity Framework的基本概念和使用方法，理解对象与数据库表的映射。





## 2023

### 一、判断题



1. **值类型和引用类型**
   - 页数：26
   - 复习建议：复习值类型和引用类型的区别，特别是int类型的本质。
2. **Equals方法**
   - 页数：137
   - 复习建议：复习Equals方法的使用，理解类实例相等性判断的机制。
3. **委托定义**
   - 页数：88
   - 复习建议：复习委托的定义和使用，理解返回值在委托定义中的作用。
4. **IList接口**
   - 页数：66
   - 复习建议：复习IList接口的特性，特别是通过索引随机访问集合的能力。
5. **WPF事件类型**
   - 页数：328
   - 复习建议：复习WPF事件类型，理解冒泡事件和下钻事件的区别。



### 二、单选题



1. **IL指令集**
   - 页数：3
   - 复习建议：复习IL指令集的特性，理解其独立于CPU的特性。
2. **构造方法特征**
   - 页数：137
   - 复习建议：复习构造方法的特征，理解构造方法不能继承的特性。
3. **函数重载**
   - 页数：82
   - 复习建议：复习函数重载的条件，理解不同参数列表的重载规则。
4. **方法参数修饰关键字**
   - 页数：82
   - 复习建议：复习方法参数修饰关键字，特别是ref、params、out和readonly的区别。
5. **委托**
   - 页数：88
   - 复习建议：复习委托的特性，理解委托封装多个带返回值的方法时的行为。
6. **常量定义**
   - 页数：61
   - 复习建议：复习常量定义的方法，理解const和readonly的区别。
7. **属性**
   - 页数：73
   - 复习建议：复习属性的定义和使用，理解属性在数据封装和隐藏中的作用。
8. **继承关系**
   - 页数：137
   - 复习建议：复习继承关系，理解不同类之间的继承和转换规则。
9. **面向对象应用**
   - 页数：137
   - 复习建议：复习面向对象编程的应用，理解派生类和基类的关系。
10. **接口实现**
    - 页数：141
    - 复习建议：复习接口实现，理解显式和隐式接口实现的区别。
11. **派生类**
    - 页数：137
    - 复习建议：复习派生类的特性，理解派生类和基类的关系。
12. **抽象方法**
    - 页数：137
    - 复习建议：复习抽象方法的定义和使用，理解抽象方法在派生类中的实现。
13. **Action委托**
    - 页数：88
    - 复习建议：复习Action委托的定义和使用，理解其在函数中的应用。
14. **Lambda表达式**
    - 页数：88
    - 复习建议：复习Lambda表达式的定义和使用，理解其在委托中的应用。
15. **String创建**
    - 页数：73
    - 复习建议：复习String对象的创建方法，理解不同方法创建String对象的区别。
16. **List排序**
    - 页数：66
    - 复习建议：复习List排序的方法，理解IComparable接口的实现。
17. **WPF布局**
    - 页数：328
    - 复习建议：复习WPF布局面板的类型，理解不同布局面板的特性。
18. **LINQ查询**
    - 页数：478
    - 复习建议：复习LINQ查询的基本方法和扩展方法，理解其在数据查询和处理中的应用。
19. **var类型**
    - 页数：26
    - 复习建议：复习var类型的使用，理解编译器自动推断变量类型的机制。
20. **FileStream对象**
    - 页数：441
    - 复习建议：复习FileStream对象的使用，理解FileMode参数的作用。



### 三、程序设计题



1. **整数列表操作**
   - 页数：88
   - 复习建议：复习委托和Lambda表达式的使用，理解如何筛选和转换整数列表。
2. **单向链表实现**
   - 页数：137
   - 复习建议：复习单向链表的实现，理解接口的定义和实现，特别是链表操作的方法。
3. **文件操作和数据统计**
   - 页数：441
   - 复习建议：复习文件操作的方法，理解如何读取文件数据并进行统计，特别是使用Dictionary和LINQ进行数据处理。



通过以上章节和页数的定位，可以更有针对性地进行复习，确保对每个考点的理解和掌握。





# 复习建议总结



1. **基础概念**：确保对C#的基础语法、数据类型、变量和表达式有扎实的理解。
2. **流程控制**：熟练掌握各种流程控制语句，特别是foreach语句的正确用法。
3. **面向对象编程**：深入理解面向对象编程的核心概念，包括继承、接口、构造方法、泛型等。
4. **委托和事件**：熟悉委托和事件的定义和使用，理解其在函数中的应用。
5. **字符串和集合操作**：掌握字符串操作和集合类型的使用方法，确保能够正确处理字符串和集合。
6. **文件操作和数据统计**：熟悉文件操作的方法，能够读取文件数据并进行统计。
7. **WPF编程**：理解WPF的基本概念和应用，熟悉WPF布局控件、控件模板和XAML文件的功能。
8. **LINQ查询**：掌握LINQ查询的基本方法和扩展方法，理解其在数据查询和处理中的应用。
9. **数据访问**：理解[ADO.NET](https://ado.net/) Entity Framework的基本概念和使用方法，掌握对象与数据库表的映射。



通过以上重点复习，可以更好地应对《C#程序设计》期末考试。







# 题目解析

## 判断：

1. int类型的本质上是结构，是值类型，所以只含数值成员，没有函数成员。  

**int作为结构，也有函数成员（tostring）**



2.返回值不属于委托定义的一部分。

**同一结构的委托的参数是共用的。定义了委托后，就可以声明该委托类型的变量。接着把这个变量初始化为与委托具有相同返回类型和参数列表的函数引用**







## 选择：

### 1.

(      )是独立于CPU的指令集，它可以被高效地转换为本机机器代码。 A．CLR				B．CLS				C．IL				D．Web服务



**C．IL 是独立于CPU的指令集**，它可以被高效地转换为本机机器代码。

解析：

* CLR（公共语言运行库）是一个运行环境，它负责执行和管理.NET程序的执行，但并不是指令集。
* CLS（公共语言规范）定义了一组语言特性和规则，以确保不同编程语言之间的互操作性，它也不是指令集。
* **IL（中间语言）**，在.NET框架中通常指的是MSIL（Microsoft Intermediate Language），是一种独立于CPU的指令集。当.NET程序被编译时，源代码首先被转换成MSIL代码。当程序运行时，JIT（Just-In-Time）编译器将MSIL代码转换成本机机器代码，以供特定的CPU执行。因此，IL（或MSIL）满足题目中“独立于CPU的指令集，且可以被高效地转换为本机机器代码”的描述。
* Web服务是一种提供网络服务的技术和架构，与指令集无关。

综上所述，正确答案是C．IL。



### 2.

下面哪个关键字不是用来修饰方法的参数? A. ref								B. params C. out								D. readonly



在C#中，当我们谈到修饰方法参数的关键字时，我们需要考虑哪些关键字允许我们改变参数在方法内的行为。

* `ref`：这个关键字用于按引用传递参数。它允许方法内部修改传递给它的变量，并且这些修改会反映到原始变量上。
* `params`：这个关键字允许你指定一个方法参数可以接受可变数量的参数。它通常与数组一起使用，但不需要显式创建数组。
* `out`：这个关键字也用于按引用传递参数，但与`ref`不同，`out`参数不需要在方法调用之前被初始化。方法必须为`out`参数赋值，然后这些值会传递回调用者。

现在来看`readonly`：

* `readonly`：这个关键字在C#中有两个主要用途。首先，它可以用来修饰字段，表示该字段只能在声明时或在构造函数中被赋值。其次，它可以用在`struct`类型的成员上，以表示这个成员只能在创建`struct`的实例时设置，之后就不能再修改了。但是，`readonly`不能用来修饰方法的参数。

因此，答案是D. `readonly`。



### 3.

(5)	关于委托的说法，不正确的是(      )。 

A. 委托属于引用类型 

B. 可以创建泛型委托类型

 C. 委托既可以封装静态方法，也可以封装实例方法

 D. 委托上封装多个带返回值的方法时，会返回一个数组以存储所有方法的返回值



关于委托的说法，我们来逐一分析每个选项：

A. 委托属于引用类型
这是正确的。在C#中，委托（delegate）是一种特殊的类型，它表示可以引用具有特定签名的方法的引用类型。

B. 可以创建泛型委托类型
这也是正确的。C# 提供了泛型委托，如 `Func<TResult>`、`Func<T1, TResult>`、`Func<T1, T2, TResult>` 等，以及 `Action` 系列的无返回值的泛型委托。

C. 委托既可以封装静态方法，也可以封装实例方法
这同样是正确的。委托可以引用静态方法（不需要实例即可调用的方法）或实例方法（需要实例才能调用的方法）。

D. 委托上封装多个带返回值的方法时，会返回一个数组以存储所有方法的返回值
这是不正确的。在C#中，一个委托实例只能引用一个方法，并且该方法在被调用时只能返回一个值（对于返回类型非 `void` 的委托）。如果你想调用多个方法并收集它们的返回值，你需要单独调用每个方法，并可能将它们的结果存储在一个集合（如数组或列表）中。

因此，不正确的说法是 D。





### 4.

 定义一个由public修饰符修饰的int型成员变量MAX_LENGTH，其值可由用户指定，但一旦指定就应保持为常数，则定义这个变量的语句是(   ) 

 A．public final int MAX_LENGTH         

B．public  const int MAX_LENGTH 

 C．public  readonly int MAX_LENGTH      

D．public  sealed int MAX_LENGTH  



在C#中，如果你想要定义一个可以由用户指定值但在之后保持为常数的成员变量，你应该使用`readonly`关键字（而不是`final`、`const`或`sealed`）。所以，正确的选项是C。

以下是每个选项的解释：

A. `public final int MAX_LENGTH` - 在C#中，`final`关键字不是用来修饰字段的。在Java中，`final`确实用于这个目的，但在C#中，你应该使用`readonly`。

B. `public const int MAX_LENGTH` - `const`字段必须在声明时初始化，并且它们的值在编译时是常量，不能在运行时更改。因此，这不满足“值可由用户指定”的要求。

C. `public readonly int MAX_LENGTH` - 这是正确的选择。`readonly`字段可以在声明时或在构造函数中初始化，之后它们的值就不能再更改了。这允许你在运行时（例如在构造函数中）设置值，但确保之后不会更改。

D. `public sealed int MAX_LENGTH` - `sealed`关键字在C#中用于类，以确保它们不能被继承。它不能用于修饰字段。

因此，正确的答案是C：`public readonly int MAX_LENGTH`。











### 5.

在C#中,以下关于属性的描述正确的是(      )

 A. 属性是以public关键字修饰的字段，以public关键字修饰的字段也可称为属性 

B. 属性是访问字段的一种灵活机制，属性更好地实现了数据的封闭和隐藏

 C. 要定义只读属性需在属性名前加上readonly关键字 

D. 属性不能在派生类中被重写







在C#中，关于属性的描述，我们可以逐个选项进行验证：

A. 属性是以public关键字修饰的字段，以public关键字修饰的字段也可称为属性

- 这个描述是不准确的。属性（Property）在C#中是一种特殊的成员，它提供了对字段的访问级别和方法。属性通常包含两个访问器：get和set，用于读取和写入字段的值。而字段（Field）是类、结构或枚举中声明的变量。仅仅因为字段被`public`修饰，它并不自动成为属性。

B. 属性是访问字段的一种灵活机制，属性更好地实现了数据的封闭和隐藏

- 这个描述是正确的。属性允许你控制对字段的访问，你可以通过属性来验证、计算或修改字段的值，而不需要直接访问字段。这有助于实现数据的封装和隐藏，是面向对象编程的一个重要原则。

C. 要定义只读属性需在属性名前加上readonly关键字

- 这个描述是不准确的。在C#中，要定义只读属性，你只需提供`get`访问器，而不提供`set`访问器。`readonly`关键字用于字段，表示字段只能在声明时或在构造函数中赋值，而不能在其他方法中赋值。属性与字段在这一点上是有区别的。

D. 属性不能在派生类中被重写

- 这个描述也是不准确的。在C#中，属性可以被标记为`virtual`或`abstract`，这样它们就可以在派生类中被重写（override）或实现（implement）。

综上所述，正确的描述是B：属性是访问字段的一种灵活机制，属性更好地实现了数据的封闭和隐藏。







## 程序题

### 1.

```csharp
//选择满足predicate的数组元素
//NumberPredicate是类型名字，predicate是声明的变量（委托）
//delegate bool NumberPredicate(int number）表明接受的参数是list中数据
private static List<int> FilterList(List<int> list, NumberPredicate predicate)
{
    List<int> ints = new List<int>();
    for (int i = 0; i < list.Count; i++)
    {
        if (predicate(list[i]))
            ints.Add(i);
    }
    return ints;
}
private static List<int> MapList(List<int> list, Func<int, int> transform)
{
    List<int> ints = new List<int>();
    for (int i = 0; i < list.Count; i++)	//list.Count是数组长度
    {
        ints.Add(transform(list[i]));	//实现掉包API就行
    }
    return ints;
}
//判断是否素数
private static bool IsPrime(int number)
{
    if (number <= 1)
        return false;
    for (int i = 2; i <= (int)(Math.Sqrt(number)); i++)
    {
        if (number % i == 0)
            return false;
    }
    return true;
}
3）
    List<int> primeNumbers = FilterList(numbers, IsPrime);
    primeNumbers.ForEach(x => Console.Write($"{x} "));
    Func<int, int> func = x => x%10;
    List<int> modNumbers = MapList(numbers, func);
    modNumbers.ForEach(x => Console.Write($"{x} "));

```



### 2.

```csharp
2、
 
class MyLinkedList : IMyList
{
    private Node head;
    private Node cursor;
    public MyLinkedList()
    {
        head = null;	//使用null简单地定义node类head属性
        cursor = null;
    }
    public MyLinkedList(params int[] arr)	//params参数接受
    {
        if (arr.Length == 0)
            return;

        head = new Node(arr[0]);
        Node pre = head;
        for (int i = 1; i < arr.Length; i++)
        {
            Node node = new Node(arr[i]);	//构造链表
            pre.Next = node;
            pre = node;
        }
        cursor = head;
    }
    public override string ToString()
    {
        String str = "";
        Node node = head;
        while (node != null)
        {
            str += $"{node.Value}--> ";
            node = node.Next;
        }
        return str;
    }
    public int Count
    {
        get
        {
            if (head == null)
                return 0;
            int count = 0;
            Node tail = head;
            count++;
            while (tail.Next != null)
            {
                tail = tail.Next;
                count++;
            }
            return count;
        }
    }
    public Node Head
    {
        get
        {
            return head;
        }
    }
    public Node Cursor
    {
        get
        {
            return cursor;
        }
        set
        {
            cursor = value;
        }
    }
    public void AddToTail(int value)
    {
        if (head == null)
        {
            head = new Node(value);
            return;
        }
        Node tail = head;
        while (tail.Next != null)
        {
            tail = tail.Next;
        }
        Node node = new Node(value);
        tail.Next = node;
    }
    public bool AddAfterCursor(int value)
    {
        if (cursor == null)
            return false;
        Node node = new Node(value);
        node.Next = cursor.Next;
        cursor.Next = node;
        return true;
    }
    public bool Contains(int value)
    {
        if (head == null || value == null)
            return false;
        Node tail = head;
        do
        {
            if (tail.Value == value)
                return true;
            tail = tail.Next;
        }
        while (tail != null);
        return false;
    }
}

```



### 3.

```csharp
string fileName = "D:/names.txt";	//目录保存形式如下
StreamReader sr = new StreamReader(fileName);
string line = sr.ReadLine();
List<Person> list = new List<Person>();
while ((line = sr.ReadLine()) != null)
{
    string[] words = line.Split(' ');
    Person person = new Person();
    person.gender = (words[0] == "男");
    DateTime.TryParse(words[1], out person.birthday);
    person.name = words[2];
    person.place = words[3];
}
sr.Close();

Dictionary<char, int> nameCount = new Dictionary<char, int>();
foreach (Person person in list)
{
if (person.gender != true || person.birthday.Year >= 2000 ||
        person.birthday.Year < 1990)
            continue;
    string name = person.name;
    for (int i = 1; i < name.Length; i++)
    {
        char c = name[i];
        if (nameCount.ContainsKey(c))
			nameCount[c]++;
        else
			nameCount[c] = 1;
    }
}
int maxCount = 0;
char maxChar = ' ';
foreach(char c in nameCount.Keys)
{
    int count = nameCount[c];
    if (count > maxCount)
    {
        maxCount = count;
        maxChar = c;
    }    
}
WriteLine($"用的最多的字是：{maxChar}，有{maxCount}次");

var query = from person in list
        where person.birthday.Year == 2000 && person.place == "杭州"
        orderby person.birthday
        select person;
WriteLine(query.Count());

```





### 1.

```csharp
static string RemoveDuplicates(string str)    {
        string newString = "";
        bool duplicate = false;
        for (int i = 0;i < str.Length; i++)
        {
            if (newString.IndexOf(str[i]) >= 0)
                continue;
            newString += str[i];
            //for (int j = 0; j < newString.Length; j++)
            //{
            //    if (str[i] == newString[j])
            //    {
            //        duplicate = true;
            //        break;
            //    }
            //}
            //if (!duplicate)
            //    newString += str[i];
            //duplicate = false;
        }
        return newString;
}

```



### 2.

```csharp
class Point3d //1{
    public double X { get; set; }//2
    public double Y { get; set; }
    public double Z { get; set; }
    public override bool Equals(object? obj)//2    {
        if (obj == null || !(obj is Point3d))//1
            return false;
        Point3d other = obj as Point3d;//1
        return DistanceTo(other) < 1.0e-6;//1
    }
    public double DistanceTo(Point3d p2)//1
{
    if(p2 == null) throw new ArgumentNullException();
        return Math.Sqrt((X - p2.X) * (X - p2.X) +
            (Y - p2.Y) * (Y - p2.Y) + (Z - p2.Z) * (Z - p2.Z));//1
    }
}
class Triangle : IComparable<Triangle>//1
{
    private Point3d[] v;//1
    public Triangle()//2
    {
        v = new Point3d[3] {
            new Point3d { X = 1, Y = 0, Z = 0 },
            new Point3d { X = 0, Y = 1, Z = 0 },
            new Point3d { X = 0, Y = 0, Z = 1 },
        };
    }
    public Triangle(Point3d[] vs)//2
    {
        if (vs == null || vs.Length != 3)
            throw new ArgumentException();
        v = vs;
    }
    public void GetLengths(out double a, out double b, out double c)//3
    {
        a = v[0].DistanceTo(v[1]);
        b = v[1].DistanceTo(v[2]);
        c = v[0].DistanceTo(v[2]);
    }
    public bool Valid//4
    {
        get
        {
            GetLengths(out double a, out double b, out double c);
            if (a + b < c || a + c < b || b + c < a)
                return false;
            else
                return true;
        }
    }
    public double Area//4
    {
        get
        {
            GetLengths(out double a, out double b, out double c);
            double p = (a + b + c) / 2;
            return Math.Sqrt(p * (p - a) * (p - b) * (p - c));
        }
    }
    public bool IsConnectedTo(Triangle t2)//4
    {
        for (int i = 0; i < 3; i++)        {
            Point3d p1 = v[i];
            for (int j = 0; j < 3; j++)
            {
                Point3d p2 = t2.v[j];
                if (p1.Equals(p2))
                    return true;
            }
        }
        return false;
    }
    public int CompareTo(Triangle? other)//4    {
        if (other == null)
            throw new ArgumentNullException();
        return Area.CompareTo(other.Area);
    }
}

```







### 3.

```csharp
 Predicate<string> isHead = (str) => str.StartsWith("第") && str.Contains('回');//4
        string dir = @"D:\三国演义\";
        string[] files = Directory.GetFiles(dir);//1
        Dictionary<string, int> counts = new Dictionary<string, int>();//2
       int times = 0;
       foreach (string file in files)//1
       {
            string title = file.Substring(file.LastIndexOf('\\') + 1, 3);//2
            StreamReader sr = new StreamReader(file);//1
            times = 0;
            while(!sr.EndOfStream)//1        {
                string line = sr.ReadLine();//1
                string[] subject = { "刘备", "玄德", "先主", "皇叔" };//1
                if (isHead(line))//3
                    continue;
                for (int i = 0; i < subject.Length; i++)//3
                {
                    if (line.Contains(subject[i]))
                        times++; 
                }
            }
            sr.Close();//1
            counts[title] = times;//3
        }
        var query = from c in counts//5
                    where c.Value > 5
                    select $"第{c.Key}回 : {c.Value}次";
        Console.WriteLine($"超过5次的章回共有：{query.Count()}个");//1
        foreach (var item in query)//2
        {
            Console.WriteLine(item);
        }
    }

```





# 章节知识点整理



## 委托



```csharp
using System;

delegate int NumberChanger(int n);	//委托中可以调用函数，委托中的参数需要与被调用函数的参数一样
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;	//共用的参数
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         // 使用委托对象调用方法
         nc1(25);	//35
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);	//175
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```





### 在C#中，一个委托实例只能引用一个方法

，并且该方法在被调用时只能返回一个值（对于返回类型非 `void` 的委托）。如果你想调用多个方法并收集它们的返回值，你需要单独调用每个方法，并可能将它们的结果存储在一个集合（如数组或列表）中。



# 复习资料



[试卷](D:\resourse\homework\2024_Csharp程序设计\试卷)

[csharp笔记](E:\programme\小笔记)

[用mooc巩固知识点](https://www.icourse163.org/learn/XJTU-1002843011?tid=1472247460#/learn/announce)

[课本位置](E:\书籍\计科专业课)